#!/bin/bash
#

if [ $# = 0 ]
then
echo
echo "vpx2mhd script"
echo
echo
echo "Convert a .vpx image to a .mhd image"
echo
echo "Usage:"
echo 
echo "vpx2mhd <image.vpx>"
echo
echo "The result is saved as image.mhd and image.raw. Wildcards are supported."
echo
echo "Currently signed/unsigned char/short/int/float/double images are"
echo "supported. Vector images are more difficult, and i don't need it now..."
echo
echo "The voxelspacing is not written, unless a vhd file exists, because it's"
echo "not stored in the vpx. You can make a .vhd with the following command:"
echo
echo "chunk im.vpx im.vpx"
echo "which generates im.vhd"
echo
echo "then with the command:"
echo "add_pixelinfo pixelsize slicethickness im"
echo "the pixelsize and slicethickness are written to im.vhd."
echo
echo "See the following link for a description of the .mhd header format."
echo "http://caddlab.rad.unc.edu/software/MetaIO/MetaIO-Introduction.htm"
echo "The field HeaderSize is not supported by this script."
echo
exit 64
fi


vpximages=`ls $*`

for vpximage in $vpximages
do

echo "Vpx-image to convert: $vpximage"

metaHeaderFile=${vpximage/%vpx/mhd}
metaElementDataFile=${vpximage/%vpx/raw}
metaElementDataFileWithoutPath=${metaElementDataFile##*/}
vhdFile=${vpximage/%vpx/vhd}

metaObjectType="Image"
metaNDims=`header -nrdims $vpximage`
metaBinaryData="True"
metaBinaryDataByteOrderMSB="False"
metaDimSize=`header $vpximage -imdims`
metaDimSize=${metaDimSize// x / }
metaElementSpacing="1 1 1"
metaElementNumberOfChannels="1"

vpxElementType=`header -type $vpximage`
#nrofbits=`echo $vpxpixeltype|cut -f2 -d"Bit"`

metaElementType="unknown"
if [ "$vpxElementType" = "VpxBit8" ]
then
	metaElementType="MET_CHAR"
fi
if [ "$vpxElementType" = "VpxUbit8" ]
then
	metaElementType="MET_UCHAR"
fi
if [ "$vpxElementType" = "VpxBit16" ]
then
	metaElementType="MET_SHORT"
fi
if [ "$vpxElementType" = "VpxUbit16" ]
then
	metaElementType="MET_USHORT"
fi
if [ "$vpxElementType" = "VpxBit32" ]
then
	metaElementType="MET_INT"
fi
if [ "$vpxElementType" = "VpxUbit32" ]
then
	metaElementType="MET_UINT"
fi
if [ "$vpxElementType" = "VpxFloat" ]
then
	metaElementType="MET_FLOAT"
fi
if [ "$vpxElementType" = "VpxDouble" ]
then
	metaElementType="MET_DOUBLE"
fi

# read the element spacing, if the vhd exists
validspacing="true"
if [ -e "$vhdFile" ]
then
  pixspac=`less $vhdFile | grep -m 1 "PIXEL_SIZE" | cut -d= -f2`

  if [ "$pixspac" = "" ]
  then 
    validspacing="false"
  fi

  metaElementSpacing="$pixspac $pixspac"  
  if [ "$metaNDims" = "3" ]
  then
    zspac=`less $vhdFile | grep -m 1 "SLICE_THICKNESS" | cut -d= -f2`
    
    if [ "$zspac" = "" ]
    then 
      validspacing="false"
    fi

    metaElementSpacing="$metaElementSpacing $zspac"
  fi  
  
  # for anything other than 2/3 dimensions i don't know how to handle spacing
  if [ "$metaNDims" != 2 ]
  then
    if [ "$metaNDims" != 3 ]
    then
      validspacing="false"
    fi
  fi

else
  validspacing="false";
fi

# convert!
if [ "$metaElementType" = "unknown" ]
then

	echo "$vpximage has unsupported pixel type: $vpxElementType"
	
else

	echo "Converting .vpx to .raw ..."
	dido -raw $vpximage $metaElementDataFile
	
	echo "Writing .mhd  header file..."
	>$metaHeaderFile
	echo "ObjectType = $metaObjectType" >> $metaHeaderFile
	echo "NDims = $metaNDims"  >> $metaHeaderFile
	echo "BinaryData = $metaBinaryData" >> $metaHeaderFile
	echo "DimSize = $metaDimSize" >> $metaHeaderFile
  
  if [ "$validspacing" = "true" ]
  then
  	echo "ElementSpacing = $metaElementSpacing" >> $metaHeaderFile
  fi

	echo "ElementNumberOfChannels = $metaElementNumberOfChannels" >> $metaHeaderFile
	echo "ElementType = $metaElementType" >> $metaHeaderFile
	echo "ElementDataFile = $metaElementDataFileWithoutPath" >> $metaHeaderFile
	echo >> $metaHeaderFile
	
	echo "Done!"
		
fi



done #for vpximage in $vpximages

